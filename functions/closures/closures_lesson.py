# Замыкание:
# Когда мы объявляем функцию, внутри которой объявляем функцию_2, но эту функцию2 не вызываем, а возвращаем
# как результат работы функции1

def func1(my_name):
    name = my_name
    def func2():
        print(name)

    return func2



# После этого присваиваем переменной в глобальной области результат работы функции 1

f = func1("Сергей")
# Теперь f() выполняет функцию func2() с переменной name = "Сергей"


# В этом случае все окружение (все переменные) функции1 не удаляются из программы, т.к. имеется глобальная ссылка
# (в нашей программе - f) на внутреннюю функцию. Локальное окружение и внешнее локальное окружение функции1
# продолжает существовать, потому что у каждого локального окружения есть неявная скрытая ссылка на внешнее окружение

# Все эти окружения не пропадают, пока ссылка f существует.

# Таким образом,
# ЗАМЫКАНИЕ - это эффект, когда мы держим внутреннее локальное окружение и имеем возможность
# использовать внешние переменные из внешних окружений


# Если вызвать функцию еще раз - создастся новое независимое локальное окружение со своими переменными
f2 = func1("Python")

# Создадим для примера функцию счетчик

def counter(start=0):
    def step():
        nonlocal start
        start += 1
        return start
    return step

c1 = counter(1)
c2 = counter(10
             )
c1() # - возвращает 2
c1() # - возвращает 3
#и т. д.

c2() # - возвращает 12
c2() # - возвращает 13
#и т. д.

# Таким образом, с помощью замыканий функции работают независимо друг от друга


# Функция, удаляющая символы (по умолчанию пробелы) в начале и в конце строки
def strip_string(strip_chars=" "):
    def do_strip(string):
        return string.strip(strip_chars)
    return do_strip

strip1 = strip_string()
strip2 = strip_string(" !?,.;")

print(strip1(" Hello Python!..  "))
print(strip2(" Hello Python!..  "))

